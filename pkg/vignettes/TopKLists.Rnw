\documentclass[a4paper,10pt]{article}
\usepackage[utf8x]{inputenc}

\usepackage{float}
\usepackage{listings}
\usepackage{inconsolata}
\usepackage{hyperref}
\usepackage{subfig}
\renewcommand*{\familydefault}{\sfdefault} 
\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}

\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}
\setlength\parindent{0pt}


<<echo=FALSE, results='hide', eval=TRUE, message=FALSE, warning=FALSE>>=
require(knitr)
options(width=60)
@



%opening
\title{TopKLists: Analyzing multiple ranked lists}
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Usage of TopKLists} 
\author{Michael G. Schimek, Eva Budinska, Shili Lin, Jie Ding, \\ Karl G. Kugler and Vendula Svendova}

\begin{document}
%%\opts_chunk$set(concordance=TRUE)

\maketitle

\tableofcontents
\newpage
\section{Introduction and example data}
\label{sec:introduction}
The ranking of distinct items has become mainstream in recent years. Examples include Web search engine results for query terms, institution league tables in higher education, preference rankings of brands, betting results in sports, results from microarray platforms in biotechnology, and meta-analysis of multiple study findings in medicine, among many others. The rank position of an object or institution might be the result of measuring the strength of evidence or of assessment based on expert knowledge or preference. The underlying space can be a person or a technical device. Typically, such lists are between several thousand and several tens of thousands of items in length. However, only a comparably small subset of \emph{k} top-ranked items is usually informative. These are characterized by a strong overlap of their rank positions when they are ranked by several independent assessors.

There are two basic statistical tasks: (i) Identification of the top-\emph{k} most conforming items. For this task, two lists are analyzed together (multiple lists in a pairwise manner). (ii) Calculation of a consolidated top-\emph{k} sublist with a new optimized ordering of the conforming items from two or more lists. For long ranked lists, (i) is a prerequisite of (ii) because for any kind of rank aggregation the top-$k$ list lengths of the individual top-$k$ lists need to be specified.

For these two tasks this package offers several options which can be selected from three modules that are provided. Various options of high practical value are supported by a graphical user interface (GUI):
\begin{enumerate}
\item \texttt{TopKInference} provides exploratory nonparametric inference for the estimation of the top \emph{k} list length of paired rankings;
\item \texttt{TopKSpace} provides several rank aggregation techniques (Borda, Markov Chain, and Cross Entropy Monte Carlo) which allow for the combination of input lists of different lengths, that may come from different underlying sets (spaces);
\item \texttt{TopKGraphics} provides a collection of graphical tools for the visualization of the inputs to, and the outputs from, the other modules.
\end{enumerate}

\textbf{Whenever you refer to the package \texttt{TopKLists}, please cite \cite{haschi} and \cite{linding}.} In the following sections, we illustrate the usage of these modules.

\subsection{The breast cancer data}

For illustrating the usage of this package, we selected three breast cancer microarray datasets (MDCC, TransBig and Pusztai) that include information on estrogen receptor positivity (ER+ vs ER-), which is one of the prognostic markers for breast cancer (for the accession numbers see Table \ref{tab:data}):



\begin{table}[h!]
\begin{center}
\label{tab:data}
\begin{tabular}{|c|c|c|c|}
  \hline
  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
  NAME & PubMed ID & GEO & Reference\\ \hline
  MDCC & 20676074 & \href{http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE20194}{GSE20194} & \cite{shi}\\
  TransBig & 17545524 & \href{http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE7390}{GSE7390} & \cite{desmedt} \\
  Pusztai & 20829329 & \href{http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE20271}{GSE20271} & \cite{tabchy}\\
  \hline
\end{tabular}
\caption{Example dataset: names, PubMed IDs, GEO accession numbers and references}
\label{tab:data}
\end{center}
\end{table}

The presence of an estrogene receptor on cancer cells discriminates between two groups of breast cancer and therefore we expected ESR1 (estrogen receptor 1 gene) to be in the first place among the differentially expressed genes. 
Given the study designs, we also expected a substantial overlap in the top ranked genes.
We begin by loading the data set and displaying the first part of the data frame, as described below.

<<message=FALSE, warning=FALSE>>=
library(TopKLists)
data(breast)
head(breast)
@


\section{Using TopKInference}

The nonparametric inference method of \cite{haschi} for the truncation of paired ranked lists forms the core part of the \texttt{TopKInference} module. The associated iterative algorithm, as implemented here, allows the estimation of the length, $k$, of a top-$k$ list in the presence of irregular and missing assignments. Overlap of rank positions in two input lists is represented by a sequence of indicators, $I$, where $I_j=1$ is the ranking, given by the second assessor to the object ranked $j$ by the first assessor, is not more than $\delta$ index positions distant from $j$, and otherwise $I_j=0$. The vector of indicators is represented by the \texttt{Idata} variable. The variables $I_j$ are assumed to follow a Bernoulli random distribution. This implies independence, which is motivated by $k\ll N$ and a strong random contribution due to irregular assignments in real data. However, \cite{haschi} could prove that their theoretical results obtained under the assumption of complete independence also applies in the situation of moderate $m$-dependence. Simulation study evidence (unpublished material) is in full support of these theoretical findings: in fact, even under substantial list dependence, stable truncation results can be obtained from \texttt{TopKInference}. 

A cautionary note: For making inference on pairs of ranked lists, tuning parameters have to be specified. This is for the following reason: For a given set of $N$ objects, arbitrary ranked lists can be constructed by successive permutations. However, this fact does not help in practice when we have to analyze realizations of such lists because they comprise irregularities in terms of position shifts, inverted orderings, missing assignments, etc. As a consequence, a unique top-$k$ list or a complete set of top-conforming objects does not exist. This is the reason why the truncation algorithm (and any other algorithm) in \texttt{TopKLists} needs to be controlled by tuning parameters. 
We therefore adhere to the well established notion of top-$k$ lists. By definition, a top-$k$ list consists of $k$ items. The next index value after $k$ is $j_0$, the point of overlap degradation ($k$=$j_0$-1).

The choice of the distance parameter $\delta$ (which takes the value $0, 1, 2, 3,\ldots $) is crucial when the \texttt{Idata} are prepared. The \texttt{deltaplot} of the module \texttt{TopKGraphics} was designed to help the user with the selection of $\delta$ for any pair of input lists of the same length. When this plot indicates more than one feasible non-zero $\delta$-value (in that area where the discordance is starting to degrade), preference should be given to the smallest value. As well as the $\delta$ value, there are two further tuning parameters: the constant $C$ which allows us to compensate for poor separability between the informative top parts and the remaining random parts of the input lists (the suggested interval is $0.25<C<0.6$), and the pilot sample size $\nu$ (for this smoothing parameter any positive integer value is admissible), which controls the degree of irregularity of the rankings.

The algorithmic solution employed by \texttt{TopKInference} in the event of there being more than two ranked lists is outlined in Figure \ref{fig:topkinference}. There, the principle for the calculation of an overall index $k^\ast$ (a function of the individual $k$'s from the $\ell$ lists $L_i$; the maximum \texttt{maxK} is the default) based on all pairwise comparisons is outlined. Having obtained such an overall index, we arrive at truncated lists $T_i$. They can either be aggregated by graphical means (the \texttt{aggmap} of the \texttt{TopKGraphics} module) or by stochastic rank aggregation (\texttt{TopKSpace} module). Details of the approach taken for multiple lists can be found in \cite{schimybu}.

\begin{figure}
\centering
\includegraphics[width=0.35\textwidth]{TopKInferenceFlowmap.pdf}\\
\caption{The inference concept to obtain $\ell$ truncated consensual lists $T_i$ from $\ell$ full ranked lists $L_i$}
\label{fig:topkinference}
\end{figure}

\subsection{Construction of a dataset and execution of the inference procedure}

In order to run the examples in this vignette, the TopKLists package must first be loaded:
<<eval=TRUE, echo=TRUE, results='hide', message=FALSE, warning=FALSE>>=
library(TopKLists)
@

The truncation point $j_0$, where noise takes over for a pair of ranked lists (i.e., the first index position after the end of the top-$k$ list), can be estimated for any prespecified distance $\delta$ and the chosen tuning parameter values $C$ and $\nu$. It should be noted that in the R source code $\delta$ is denoted by d, $C$ by const and $\nu$ by v. In this example we simulate a dataset with an assumed top length of $k=30$, hence the truncation point of $j_0=31$.

<<tidy=FALSE>>=
k = 30
set.seed = 11
x = c(rep(1,k), rbinom(100, 1, 0.2))
@

Now let us estimate $j_0$ for different values of $\nu$ using the \texttt{compute.stream} function. This outputs a list of estimated  $j_0$ values, as well as other details of the algorithm's convergency.

<<tidy=TRUE>>=

v.vect=seq(2,length(x), by=2) #setting up a vector of the nu values

resF=c()

for (v in v.vect)
 {
	res=compute.stream(x, const=0.5, v)
	resF=rbind(resF,c(v,paste(res)))
 }

colnames(resF)=c("v", "j0_est", "k","reason.break", "Js", "v.vector")
head(resF)

table(resF[,2])
@

\subsection{Visualization of the truncation results}

The following plot (Figure~\ref{fig:truncPlot}) summarizes the obtained estimation results $\hat{j}_0$ for the specified range of pilot sample sizes $\nu$ and the assumed point of degeneration $j_0=31$. Small values of $\nu$ are the most appropriate here.

<<truncPlot, out.width='8cm', out.height='8cm', fig.pos="ht!", fig.cap="Estimation of $j_0$ for different values of $\\nu$", fig.align='center'>>=
plot(resF[,1], resF[,2], pch=19, ylim=c(0, length(x)), 
xlab=substitute(nu), ylab=substitute(paste(hat(j)[0])))
abline(a=31, b=0, col="red")
lines(resF[,1], resF[,2])
@

\section{Using TopKSpace}
\label{sec:topkspace}



The principle of the \texttt{TopKSpace} module is to consolidate information from
the $l$ top-\emph{k} lists to arrive at an aggregate list, $AL$. 
As shown in Figure \ref{fig:topkspace}, the top-\emph{k} lists
($L_1, L_2, \ldots, L_l$) may not only be of different lengths, they may also come from studies or assessments that consider different sets of objects, hence the underlying spaces ($S_1, S_2, \ldots, S_l$) from which the top-\emph{k} lists are derived may actually be different. The goal of the inference in \texttt{TopKSpace} is to therefore find the top-\emph{k} list, $AL$, from the aggregate new space ($\cup_{i=1}^l L_i$), 
such that the weighted sum of distances between each of the input lists and $AL$ will be the minimum among lists of the same length.
Two distance measures, Kendall's $\tau$ and Spearman's footrule, are available in the package. Both take the differences in the underlying spaces into account \cite{lin2010}. 
There are three common assumptions about the underlying spaces: {\em common-space} (all top-\emph{k} lists come from a single common space), {\em underlying space-dependent}, i.e. {\em assessment-} or {\em platform-dependent} (using the known spaces from which the top-\emph{k} lists were generated), and {\em top-k-space} 
(treating each top-\emph{k} list as its own space). Since underlying space-dependent represents the true underlying scenario, this method is recommended if such information is available.

There are three classes of algorithms implemented in \texttt{TopKSpace}, namely
Borda's method, Markov Chain (MC) algorithms \cite{lin}, 
and a Cross Entropy Monte Carlo (CEMC) method taking advantage of the new Order Explicit Algorithm (OEA) as described by \cite{linding}.
The Borda and Markov Chain methods consist of heuristic algorithms which do not directly optimize the objective function (i.e., minimizing the weighted distances), whereas the CEMC method employs a Monte Carlo search procedure for achieving this optimization. Borda and Markov Chain algorithms run much faster than the Cross Entropy Monte Carlo algorithm, however the latter usually achieves better results. Nevertheless, simulation studies indicate that taking the underlying space into consideration has a much greater impact than using different algorithms.
These three algorithms are implemented in three top-level functions within \texttt{TopKSpace}: \texttt{Borda}, \texttt{MC}, 
and \texttt{CEMC}. There are also two plotting functions: \texttt{Borda.plot} and \texttt{MC.plot} that help the user to visualize 
and compare the results.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{TopKSpaceSchema.pdf}\\
\caption{The optimization concept for the aggregation of $\ell$ full ranked lists $L_i$ into one list $AL$ under space consideration}
\label{fig:topkspace}
\end{figure}


\subsection{Construction of three input lists and underlying spaces} \label{sec:data}
Let us first produce the following three ranked lists of different lengths and their underlying spaces.
Although this example is contrived, it is realistic in terms of the lengths and the number of top-\emph{k} lists.

<<>>=
L1=1:30
L2=c(1:10,31:40,11:15)
L3=c(1:10,16:20,11:15)
input=list(L1,L2,L3)
space=list(1:40,1:40,1:40)
@

As can be seen from the compositions of the three lists, they are of different lengths (30, 25, and 20
for L1, L2, and L3, respectively). Further, the
aggregate candidate set is objects 1-40, although two of the underlying spaces are larger, indicating that
objects 41-50 were not selected in the top-\emph{k} of the two corresponding lists. Fifteen of these 40 objects 
appear in all 3 lists, with objects 1-10
ranked 1-10, in that order, in all three lists;  objects 11-15, however,
have different rankings 
(they are ranked 11-15 for L1, 20-25 for L2, and 16-20 for L3). 
Five objects, 16-20, appear in two of the lists, with rankings of 16-20 for L1 and 11-15 for L3.
The remaining 20 objects, 21-40, appear on only one list (objects 21-30 
are ranked 21-30 in L1, while objects 31-40 are ranked 11-20 in L2). Since the number of 
potential aggregate top-40 lists is more than $8 \times 10^{47}$, enumerating all of them to find the 
``true'' answer is not possible, but it would be reasonable to make a fairly
accurate guess. There should be
overwhelming information for ranking objects 1-10 in the top-10. Objects 11-15 should come next, followed
by 16-20. For the remaining of the objects, 31-40 should be ranked ahead of
21-30. In the following subsection, we will demonstrate the use of the three classes of algorithms (\texttt{Borda}, \texttt{MC}, \texttt{CEMC}) for aggregation of these three ranked lists.
We will also demonstrate the use of an objective evaluation criterion to compare the
relative performances of different algorithms.




\subsection{Function calling}
\subsubsection{The Borda algorithm}
Four Borda scores are implemented in the \texttt{Borda} function of \texttt{TopKSpace}, namely the arithmetic mean (ARM), median (MED),
geometric mean (GEO), and L2-norm (L2N). The output is a list with two elements: \texttt{Top-K} provides
the aggregate rankings and \texttt{Scores} gives the corresponding Borda scores
for each of the four functions.
Of the three arguments in \texttt{Borda}, only the first one ({\em input}) is required. If argument {\em space} is not
provided, then the underlying space is assumed to be common among all top-\emph{k} lists implicitly, and the union of
the top-\emph{k} lists is treated as the common space. If argument {\em k} is not specified, then the full ranked
list (all elements in the union) is outputted.
 

<<>>=
outBorda=Borda(input,space,k=50) 
# "space" is explicitly specified; underlying space-dependent
@

<<>>=
outBorda1=Borda(input) 
#"space" is not specified; all lists are assumed to come from the common space (objects 1-40)

@

<<>>=
outBorda2=Borda(input,space=input) 
# "space = input" indicates that this is the top-k space
@

<<>>=
sum(outBorda$Scores-outBorda1$Scores)
sum(outBorda$Scores-outBorda2$Scores)
@

Comment 1: Objects 1-40, union of the three top-k lists, are contained in all three spaces. As such, the results for which the spaces were explicitly
specified should be the same as those with the common space assumption, which was exactly what we saw above. On the 
other hand, the underlying space-dependent results were different from the results
assuming top-\emph{k} spaces (i.e., all lists were full ranked lists).

<<>>=  
as.list(outBorda$TopK)
@

Comment 2: All four scoring functions ranked objects 1-10, in that order, in the top-10. However,
despite our expectation that objects 11-15, in that order, should be ranked 11-15, followed by
objects 16-20, the results were more of a mix of these two groups, but with the correct
relative orders preserved within each group. The results are quite similar among the four scoring 
functions.
This result is not surprising
due to degradation of ranking information beyond the top 10. 
Such information degradation can be seen by plotting the 
Borda scores as described in the following.   
\\[2ex]

Plotting the Borda scores against the ranking can frequently reveal when information for
ranking starts to diminish. For example, Figure~\ref{fig:borda}(a) shows that for the
underlying space-dependence approach, a large gap appears between the Borda scores 
at rankings 10--11, and that the changes of the scores also slow down after this point.
This can be similarly observed for the scores under the 
top-\emph{k} space assumption (Figure~\ref{fig:borda}(b)). \\


<<borda, fig.cap='Plotting Borda\'s scores', fig.subcap=c('underlying space-dependent analysis','top-k space analysis'), out.width='.49\\linewidth', fig.pos='ht!', fig.align='center'>>=
Borda.plot(outBorda, k=40) # plot scores from underlying space-dependent analysis
Borda.plot(outBorda2) # plot scores from top-k space analysis
@




Note that the first argument of the \texttt{Borda.plot} function is the output from the Borda function, which is 
mandatory. If the number of ranked objects (second argument) is not specified, the plot will show 
scores for all objects in the union set. 
 
%% \begin{figure}[h]

%% \begin{center}

%% %@
%% 	\includegraphics[scale=0.6]{bordaPlot.pdf}\\
%% \end{center}
%% \caption{Plot of Borda scores against ranking: (a) results from platform-dependent 
%% analysis; (b) results from top-k space analysis.}

%% \label{borda}
%% \end{figure}

\subsubsection{Three MC algorithms}
Three Markov Chain (MC) algorithms are implemented in the \texttt{MC} function in
\texttt{TopKSpace}: MC1 (spam sensitive), 
MC2 (majority rule), and MC3 (proportional). 
Among them, \texttt{MC3} may be more appropriate for multi-platform omics problems given the potential of unique features of each data type.
The output is a list with two elements for each of the \texttt{MC} algorithms (aggregate top-\emph{k} list: \texttt{MC1.TopK}, \texttt{MC2.TopK}, or \texttt{MC3.TopK}; stationary probability distribution: \texttt{MC1.Prob}, \texttt{MC2.Prob}, or \texttt{MC3.Prob}). 
Of the arguments in \texttt{MC}, only the first one, {\em input}, is required. If argument {\em space} is not provided, it is assumed that the underlying space is common among all top-\emph{k} lists, and the union of
the top-\emph{k} list is supplied as the common space. If argument {\em k} is not specified, then the full ranked list (all elements in the union) is outputted.
The other two arguments ($a$ and $delta$; the latter different from $\delta$ in \texttt{TopKInference}) are tuning parameters, whose default values were shown to work well in a number of examples.


<<>>=
outMC=MC(input,space) 
# "space" is explicitly specified; underlying space-dependent
@


<<>>=
outMCa=MC(input,k=30) 
# "space" is not specified, so it is the same as common space (1-40)
@


<<>>=
outMCb=MC(input,space=input) 
# "space = input" indicates that this is the top-k space
@

<<>>=
sum(outMC$MC2.Prob-outMCa$MC2.Prob)
sum(abs(outMC$MC2.TopK-outMCb$MC2.TopK))
@



Comment 1: 
Similar to the discussion for running the \texttt{Borda} function, 
 the results for which the space was explicitly
specified were expected to be the same as those run with the common space
assumption, which was exactly what we saw above (the two stationary distributions were identical). On the
other hand, the common-space results were different from those assuming 
top-\emph{k} space (there were large discrepancies in the aggregated top-\emph{k} lists).

<<>>=
list(outMC$MC1.TopK, outMC$MC2.TopK, outMC$MC3.TopK)
@



Comment 2: All three \texttt{MC} algorithms ranked objects 1-10, in that order, in the top-10. \texttt{MC2} also ranked the next two groups, 11-15 and 16-20 in the correct 
order. However, the remaining objects (21-40) were ranked in the reverse of
the expected order. \texttt{MC3}, on the other hand, had all the correct ordering 
except a transposition between the order of objects 15 and (16, 17).
The stationary probabilities can be visualized using the plotting function (described in
the following), which can be used to detect information degradation heuristically.
\\[2ex]
The stationary probabilities can be plotted by\\

<<equil, include=TRUE, fig.cap='Equilibrium probabilities', fig.pos='ht!', out.width='9cm', out.height='9cm', fig.align='center'>>=
MC.plot(outMC)
@
A plot of the ordered stationary probabilities versus the ranking using the above command can contain useful information
regarding the relative rankings of objects. 
For example, Figure~\ref{fig:equil} shows that 
for \texttt{MC2}, there was considerable information for ranking objects in the top-20,
but there was practically no information ranking any object after that (all 
stationary probabilities are the same). This was the reason why the rankings for objects
21-40 were completely wrong as we saw in the output.
On the other hand, for \texttt{MC1}, there was less information for ranking
objects beyond the top-10 compared to \texttt{MC2}, thus objects 11-20 were not ranked
correctly. \texttt{MC3} appears to be a compromise between \texttt{MC1} and \texttt{MC2}, leading to a better 
aggregate ranked 
list.



%% \begin{figure}[h]
%% \begin{center}
%% \includegraphics[scale=0.8]{equil.pdf}\\
%% \end{center}
%% \caption{Equilibrium probabilities}
%% \label{equil}
%% \end{figure}

Note that the first argument of the \texttt{MC.plot} function is the output from the \texttt{MC} function, which is
mandatory. If the number of ranked objects (second argument) is not specified, the plot will show
probabilities for all objects in the union set.

\subsubsection{The CEMC algorithm}
The Order Explicit Algorithm (OEA) in \cite{linding} is implemented as the \texttt{CEMC} function in \texttt{TopKSpace}.
Of the three main input arguments in \texttt{CEMC}, only the first one ({\em input}) is required. If argument {\em space}
is not provided, then all the underlying spaces are assumed to be a common one, and the union of 
the input top-\emph{k} lists is supplied as the common space. If argument {\em k} is not specified, then the full 
aggregate ranked-list (all elements in the union) is outputted. 
The function also has a number of other arguments, all tuning parameters, that can be set to run the OEA more efficiently.
The default specified in the \texttt{CEMC} function constitutes a set of 
values that seem to work well for the examples/data that we have analyzed in \cite{linding}, but it is always a good idea
to run OEA with multiple sets of tuning parameters to increase the chance of finding 
the global maximum; see \cite{linding} for some recommendations on how to choose these 
parameters. In fact, the output of \texttt{CEMC} contains the set of tuning parameters used in the current run. If  users
are unsure of what to use, they are recommended to run \texttt{CEMC} without setting any parameter and use 
the parameter file in the output ({\em input.par}) to fine-tune the parameters and apply them as input
for a more refined analysis. For the convenience of the user, after the parameter values are 
modified, the file can be directly supplied as an input argument without having to enter the value of 
each tuning parameter separately.
Other than {\em input.par}, there are two more elements in the output list. 
One is the 
aggregate top-\emph{k} list ({\em TopK}). The other is the multinomial probability matrix ({\em ProbMatrix};
each column 
represents the probability vector of a multinomial distribution and thus sum to 1, albeit with
small rounding
errors), from which the aggregate top-\emph{k} list is determined.

<<>>=
set.seed(12345)
outCEMC=CEMC(input, space, N=8000)  
# "space" is explicitly specified; underlying space-dependent
@


<<>>=
list(outCEMC$TopK)
outCEMC$ProbMatrix[1:5,1:5] 
@

Comment 1: From the submatrix shown above for \texttt{CEMC}, it can be seen that item one is ranked no. 1, since the probability vector in the first column for item one is almost 1, but very small for the rest of the items. Similarly, item 2 is ranked no. 2, and so on.

<<>>=
outCEMC$input.par
@

Comment 2: This file contains all the tuning parameter values (defaults) for running \texttt{CEMC}. User may
modify this file and use it as the input to the {\em input.par} argument in
the \texttt{CEMC} function.

\subsection{Comparison of performance of the different algorithms}
In the example given above, we discussed the performances of the different 
algorithms and assumptions since the underlying truth can be guessed to a large extend since
the example was contrived.
However, in a real data application, the ground truth is typically completely unknown,
therefore, it would be helpful to have some objective criterion to evaluate the relative
performances of the various algorithms. To this end, we have implemented two functions 
based on the modified Kendall distance (MKD) \cite{lin} in the \texttt{TopKSpace} module. The first 
function is \texttt{Kendall}, which computes the weighted sum of 
MKD between an aggregate top-\emph{k} list with the input lists. 
Of the input arguments, the first two ({\em input, aggregate}) are required. If argument
{\em space} is not supplied, all input lists are assumed to come from the same underlying
space, the union of all elements in the input. If user has prior information on which list
is more informative, then that information can be utilized by specifying the weight vector
{\em w}.
The output of \texttt{Kendall} is the \texttt{MKD}, a single number. However, it would be much more meaningful
to compare \texttt{MKD}s accross results from different algorithms to assess their relative
performances. This can be achieved by invoking the \texttt{Kendall.plot} function, which not only 
provide a vector of \texttt{MKD}s but also provide a plot of the \texttt{MKD}s for ease of comparison visually.
There are also two mandatory input arguments, {\em input} and {\em all.aggregates},
where \texttt{all.aggregates} is a list comprising of aggregate top-\emph{k} lists from different 
algorithms to be compared. 

The following command will compute the \texttt{MKD} for the aggregate list form the  
Borda algorithm \texttt{ARM}.

<<>>=
KendallMLists(input,space, outBorda$TopK[,1])
all.aggregates=list(outBorda$TopK[,1],outBorda$TopK[,2],outBorda$TopK[,3],outBorda$TopK[,4],outMC$MC1.TopK,outMC$MC2.TopK,outMC$MC3.TopK,outCEMC$TopK)
@
<<plotKendall, include=TRUE, tidy=TRUE, echo=TRUE, out.width='8cm', out.height='8cm', fig.pos='H',fig.cap="Comparison of the modified Kendall distances across several algorithms", fig.align='center'>>=
Kendall.plot(input,all.aggregates,space,algorithm=c("ARM","MED","GEO","L2N","MC1","MC2","MC3","CEMC"))
@
Runing the \texttt{Kendall} function returns the \texttt{MKD} for the aggregate list from the
Borda algorithm \texttt{ARM}, whereas the \texttt{Kendall.plot} function returns a vector of \texttt{MKD}s, with
the first one matching the output from the \texttt{Kendall} function.
Figure~\ref{fig:plotKendall} is the graphical component of the \texttt{Kendall.plot} output.
As we can see, the range on the y-axis is very small, indicating similar performance of 
all algorithms, especially those from \texttt{Borda}. The result from \texttt{MC3} seems to perform a bit 
better than the rest, confirming our heuristic interpretation of the results. 



\subsection{Application to the breast cancer example dataset}
We apply the Borda, MC, and CEMC algorithms to the breast cancer data to illustrate their usage in real data application.
<<>>=
data(breast)
@
Now the overall top-$k$ list length \texttt{maxK} is calculated using the \texttt{j0.multi} function
<<>>=
res = j0.multi(breast, d=6, v=10)
res$maxK
@
Each of the three lists is truncated to the 14 most highly ranked genes. The set
 of genes contained in each list is not identical and each list can contain a di
fferent set of 14 top genes. Since each of the top-14 gene lists come from the c
ommon set of 917 genes, one way to set the common underlying space, without loss
 of information, is to make it the set of all the genes present in these 3 trunc
ated lists. In this case there are 22 unique genes. 
<<>>=
l1=as.character(breast[1:res$maxK,1])
l2=as.character(breast[1:res$maxK,2])
l3=as.character(breast[1:res$maxK,3])
input=list(l1,l2,l3)
common=unique(unlist(input))
space=list(common,common,common)
outBorda=Borda(input,space)
outMC=MC(input,space)
outCEMC=CEMC(input,space,N=2000)
@

Display results in a matrix form for comparison
<<>>=
agg=list(ARM=outBorda$TopK[,1],MED=outBorda$TopK[,2],GEO=outBorda$TopK[,3],L2N=outBorda$TopK[,4],MC1=outMC$MC1.TopK,MC2=outMC$MC2.TopK,MC3=outMC$MC3.TopK,CEMC=outCEMC$TopK)
head(do.call(cbind, agg))
@ 

Additionally, we can plot the results from the different function.

<<aggplot, out.width='8cm', out.height='8cm', fig.pos="ht!", fig.cap="Results from different algorithms for the breast cancer example data", fig.align='center'>>=
Kendall.plot(input,agg,space,algorithm=c("ARM","MED","GEO","L2N","MC1","MC2","MC3","CEMC"))
@ 

Note: The results indicate that Borda with the median function and CEMC perform the best in this example as they lead to the smallest distance between the aggregate and individual lists (\ref{fig:aggplot}).



\section{Using TopKGraphics}

The \texttt{TopKGraphics} module comprises three graphical tools: namely, the deltaplot, the aggregation map, and the Venn diagram. All are introduced in the following sections and illustrated using example data.


\subsection{Deltaplot}
The function \texttt{deltaplot} provides an exploratory graph, designed to help the user with selecting the distance parameter $\delta$ in the \texttt{TopKListsGUI} interface. 
The input for the moderate deviation-based inference procedure is a sequence of $I$'s, taking
either zero or one, forming a data stream representing the concordance of the paired ranks of an
object $o$. The data stream depends on some value for the distance $\delta$. The parameter $\delta$ is defined by the shift in
index positions of a particular object~$o$ in one list, say $L_i$, with respect to the other list, say $L_j$. This
means that we assume concordance (i.e. $I = 1$) for an arbitrary object characterized by rank positions
in $L_i$ versus $L_j$ , maximal $\delta$ index values apart.
For the identification of an appropriate $\delta$ in real data analysis, the following strategy is employed: we compute all data streams for $\delta \in [0,1,2,\ldots,N-1]$ and
order the data stream vectors column-wise according to increasing $\delta$ values. In this way, we obtain a $N\times N$ matrix $\Delta$. The ordered sequence
of column sums (i.e. the number of 0's) for $\delta \in [0,1,2,\ldots,N-1]$) is the information we take advantage of in
the so-called \textit{deltaplot}. It represents the reduction of discordance as a function of $\delta$. When all column
sums remain zero, complete concordance is attained. A reasonable choice for the distance parameter
is associated with a distinct decline in the number of 0's. Generally one should choose a value for $\delta$ where the rate of the deltaplot's decrease begins to slow noticeably. Of course, prior information about the ranking mechanisms involved and the nature of the data is also relevant for the selection of $\delta$. 


<<>>=
deltaplot.dir =  paste0(tempdir(), "/deltaplot")
dir.create(deltaplot.dir, showWarnings = FALSE)
subplot.dir = paste0(tempdir(), "/subplot")
dir.create(subplot.dir, showWarnings = FALSE)
@ 

<<fig.show='hide'>>=
a=deltaplot(breast, deltas = seq(0,300, by=5), directory=deltaplot.dir) 
@ 

\begin{figure}[H]
\centering
\includegraphics[scale=0.35]{\Sexpr{gsub("\\\\", replacement="/", deltaplot.dir)}/deltaplotL2-3.pdf}\\
\caption{Deltaplot for lists MDCC vs. Pusztai}
\label{fig:deltaplot_complete}
\end{figure}

When observing the deltaplot for the first two breast cancer dataset lists (Figure \ref{fig:deltaplot_complete}), it is not immediately apparent which value for $\delta$ should be used. This is because there is no visible point where the \texttt{deltaplot}'s decrease changes its direction. 


It can also be observed from the Figure~\ref{fig:deltaplot_complete} that switching the reference list from, for example \texttt{Putsztai} to \texttt{MDCC} or vice versa, has little impact on the graph.
In order to choose a suitable value for $\delta$, we must limit the deltaplot calculation to a smaller subset of the investigated lists, for example the first 200 objects. Additionally, the \texttt{subplot} parameter can be used, which magnifies a selected range of small $\delta$-values in a subplot, defined by the \texttt{perc.subplot} parameter.

<<fig.show='hide'>>=
a=deltaplot(breast, deltas = 1:50, subset.lists=200, subplot = TRUE, perc.subplot=50, directory=subplot.dir)
@


\begin{figure}[H]
\centering
\includegraphics[scale=0.35]{\Sexpr{gsub("\\\\", replacement="/", subplot.dir)}/subplotL2-3.pdf}\\
\caption{Deltaplot for lists MDCC vs. Pusztai for first 200 objects}
\label{fig:deltaplot_subset200}
\end{figure}
In Figure \ref{fig:deltaplot_subset200} it can be seen that after, say, $\delta=6$ the decrease of \textit{deltaplot} is not as pronounced as for lower values of $\delta$. Therefore, it would be logical to concentrate on those results where $\delta$ is set to between 4 and 10. 

The calculation of the overall truncation index \texttt{maxK} for pre-specified values of $\delta$ and $\nu$ is performed using the \texttt{j0.multi} function. 
This function takes the input lists, calculates for all pairwise list combinations \texttt{Idata} vectors of 0's and 1's, and then estimates the $\hat{j}_0$. 
Finally, the \texttt{maxK} is calculated as the maximum of all pairwise $\hat{k}$ values. 

<<>>=
res = j0.multi(breast, d=6, v=10)
sapply(res, head)
@

In our example, for $\delta=6$ and $\nu=10$, the estimated overall top-\emph{k} takes the value \texttt{maxK=14}.
 
\subsection{Aggregation map} 
The aggregation map can only be accessed via \texttt{TopKListsGUI} (see Section~\ref{subsec:resultspanel}). It can be characterized as follows: We define an index $p=1,2,\ldots$ and combine $\ell-1$ aggregation levels (groupings of truncated lists) in one display: 
For each group of $\ell-p$ truncated lists down to the smallest group consisting of just one pair of lists, we (i) select an arbitrary reference list $L^0$ under the condition that it 
comprises $\max_i(\hat{k}_i)$ items among all pairwise comparisons in the group of rankings, (ii) print the symbols of its $\max_i(\hat{k}_i)$ items vertically from the highest 
to the lowest rank position, and (iii) add the aggregation information for all remaining $\ell-p$ rankings (pairwise list combinations) in the group, ordered according to descending list length.

The aggregation information per symbol, item, and group consists of three measures represented by colored triangles and rectangles, respectively, outlined in an array format: 
\begin{description}
  \item[a)] The \textbf{membership} of an individual item in the top-\emph{k} lists. \textit{Yes} is denoted by the color `grey' and \textit{no} by the color `white'. 
  \item[b)]  The \textbf{distance} $d$ of the rank of an individual item $o\in L^0$ from its position in another list, is denoted by a triangle color scaled from `red' \textit{identical} to 
`yellow' \textit{far distant}. An additional integer value gives the numerical distance between the item's rank positions, a negative sign means ranked lower, and a positive sign means 
ranked higher in $L$ with respect to $L^0$. 
  \item[c)] The rectangular of a symbol takes on the color `grey' when the \textbf{percentage} of $d \leq \delta$ across the columns of a group is above 
some prespecified threshold, and `white' otherwise.
\end{description}
The aggregation map of the breast cancer dataset can be seen in Figure \ref{aggmap} for instance.

\subsection{Venn diagram}
The Venn diagram can only be accessed via \texttt{TopKListsGUI} (see Section~\ref{subsec:resultspanel}).
The Venn diagram, and the respective Venn table, show overlaps of objects in the top-\emph{k} lists for all analyzed input lists. Asterisk-highlighted objects are those from the final aggregated list, produced by \texttt{TopKSpace}.

\section{Using TopKListsGUI}


The \texttt{TopKLists} package comprises a graphical user interface \texttt{TopKGUI} that offers applied researchers easy and straightforward access to all the functionality of \texttt{TopKInference} as well as access to the aggregation techniques of \texttt{TopKSpace}, and the \texttt{aggmap} graphical aggregation tool contained in \texttt{TopKGraphics}. Moreover, Venn-diagrams and Venn-tables for the summary of rank aggregation results are accessible. The \texttt{TopKSpace} results are shown in the Venn diagram output.

The suite of functions supported by \texttt{TopKGUI} facilitates the exploratory analysis of multiple ranked lists. 
Interactive input facilities (such as a slider for the dynamic specification of the distance $\delta$) allow for the real-time analysis and visualization of results. These results correspond to the distance $\delta$ or the pilot sample size $\nu$ (note that, for large list lengths of $N$, many numbers of calculations must be performed and longer waiting times should be expected). 

\subsection{The graphical user interface}
To open the GUI using the breast cancer data introduced in \ref{sec:introduction}, run
<<eval=FALSE>>=
TopKListsGUI(breast)
@ 
The window shown in Figure~\ref{topkguistart} appears, allowing the user to perform an analysis of two or more lists.

\begin{figure}[H]
\centering
\includegraphics[scale=0.35]{TopKListsGUI-1.png}\\
\caption{Main windows of the \texttt{TopKListsGUI}
\label{topkguistart}}
\end{figure}
The TopKListsGUI window is divided into four panels: Arguments, Delta-slider, Results and Analysis Status.

\subsubsection{Arguments}

\begin{figure}[H]
\centering
\includegraphics[scale=0.35]{TopKListsGUI-1-Arguments.png}\\
\caption{The Arguments panel of the \texttt{TopKListsGUI} main window
\label{topkgui}}
\end{figure}

In this panel, the user is informed about the number of lists and objects in the dataset. Further, the user can set up variable values for the top-\emph{k} list computation. 
The user must select $\nu$ (default value is 10) and choose the $\delta$ range for which the top-\emph{k} lists should be calculated (the default is from 0 to 10, in steps of 1). 
A threshold for the minimum percentage of top lists comprising an object, used for gray-shading in the aggregation map, can also be selected (default is 50). 
Finally, the \texttt{TopKSpace} algorithm for the generation of the aggregate list can be chosen, the default being \texttt{CEMC}. Last but not least, this panel contains the Calculate button, which starts the analysis.


\subsubsection{Analysis status panel and delta-slider}

In the bottom section of \texttt{TopKListsGUI} the status of the analysis is shown. 

\begin{figure}[H]
\centering
\includegraphics[scale=0.2]{TopKListsGUI-1-DeltaSlider.png}\\
\caption{The delta-slider section of the \texttt{TopKListsGUI} main window
\label{topkgui}}
\end{figure}

Once the analysis is complete, the delta-slider allows the user to switch between the results obtained using different values for $\delta$ interactively. The moving bar shows the current value of $\delta$, and the aggregation map updates accordingly. Moving the bar to the left or right allows the user to see results for smaller or larger $\delta$ values.


\subsubsection{Results panel}
\label{subsec:resultspanel}
Once the analysis phase is complete, this section serves as the visualization for the results for the selected $\delta$ value (the position of the delta-slider). The results of the analysis are separated into three tabs, described below.

\begin{itemize}
\item{\texttt{Aggregation map}}

\begin{figure}[H]
\centering
\includegraphics[scale=0.35]{TopKListsGUI-2-Results.png}\\
\caption{\texttt{TopKListsGUI} aggregation map result
\label{aggmap}}
\end{figure}

As shown in Figure~\ref{aggmap}, the best overlap was found when comparing the MDCC and Transbig lists against the Pusztai list, for $\delta = 6$ (see Section~\ref{sec:introduction} for a description of the example datasets). The estimated $\hat{k}$ is 14, with 12 genes in the top-\emph{k} lists of at least two datasets. In the visualization of Transbig with respect to MDCC, 10 genes are grey-shaded. Most consistent are the ESR1 and TBC1D9 genes, occupying the first two positions in all three lists (with a distance of 0 in both MDCC and TransBig compared to Pusztai).\\


\item{\texttt{Summary table}}:\\ The summary table displays a table of objects present in at least one of the top-\emph{k} lists, as shown in the aggregation map. The table describes each object name, position of the object in each of the lists, sum of ranks, frequency in the input lists, and frequency in the truncated lists. Please note, that the objects assigned the value `YES' in the first column are in the top-\emph{k} set of genes (as selected by the \texttt{CEMC} function explained in Section~\ref{sec:topkspace}).

\begin{figure}[H]
\centering
\includegraphics[scale=0.35]{TopKListsGUI-2-SummaryTable.png}\\
\caption{Summary table result of \texttt{TopKListsGUI}
\label{topkgui}}
\end{figure}

The table is ordered in ascending order with regard to the sum of ranks of the objects in the three lists. The first object is gene ESR1, followed by TBC1D9. Genes SCUBE2, EVL, FBP1, CIRBP, and BTG2 are also consistently present in the top-\emph{k} truncated lists, but at different positions. Genes FUT8, C1orf106 and QDPR are found in only two of the truncated lists and at varying positions.

\item{\texttt{Venn-diagram and Venn-table}}:\\ The outputted Venn diagram and Venn table show overlaps of objects in the top-\emph{k} lists of all input lists in the analysis. The asterisk-highlighted objects, in this example the genes, are those that belong to the final aggregate list as returned by the \texttt{TopKSpace} module.

\begin{figure}[H]
\centering
\includegraphics[scale=0.35]{TopKListsGUI-2-Venn.png}\\
\caption{\texttt{TopKListsGUI} Venn-diagram and Venn-table results
\label{venn}}
\end{figure}

\end{itemize}



\bibliographystyle{plain}
\begin{thebibliography}{}

\bibitem{desmedt} Desmedt C., Piette F., Loi S., Wang Y. et al. (2007). Strong time dependence of the 76-gene prognostic signature for node-negative breast cancer patients in the TRANSBIG multicenter independent validation series. \emph{Clin Cancer Res}, \textbf{13}, 3207-3214. 

\bibitem{haschi} Hall, P. and Schimek, M. G. (2012).  Moderate deviation-based inference for random degeneration in paired rank lists. \emph{J. Amer. Statist. Assoc.}, \textbf{107}, 661-672.

\bibitem{linding} Lin, S. and Ding, J. (2009). Integration of ranked lists via Cross Entropy Monte Carlo with applications to mRNA and microRNA studies. \emph{Biometrics}, \textbf{65}, 9-18.

\bibitem{lin2010} Lin, S. (2010a). Space oriented rank-based data integration. \emph{Statistical Applications in Genetics and Molecular Biology}, \textbf{9}, Article 20.

\bibitem{lin} Lin, S. (2010b). Rank aggregation methods. \emph{Wiley Interdisciplinary Reviews: Computational Statistics}, \textbf{2}, 555â€“570.

\bibitem{schimybu} Schimek, M. G., My\v{s}i\v{c}kov\'{a}, A. and Budinsk\'{a}, E. (2012). An inference and integration approach for the consolidation of ranked lists. \emph{Communications in Statistics - Simulation and Computation}, \textbf{41:7}, 1152-1166.

\bibitem{shi} Shi L., Campbell G., Jones W.D., Campagne F. et al. (2010). The MicroArray Quality Control (MAQC)-II study of common practices for the development and validation of microarray-based predictive models. \emph{Nat Biotechnol}, \textbf{28}, 827-838. 

\bibitem{tabchy} Tabchy A., Valero V., Vidaurre T., Lluch A. et al. (2010). Evaluation of a 30-gene paclitaxel, fluorouracil, doxorubicin, and cyclophosphamide chemotherapy response predictor in a multicenter randomized trial in breast cancer. \emph{Clin Cancer Res} \textbf{16}, 5351-5361. 
 

\end{thebibliography}


\section*{Session info}
<<>>=
sessionInfo()
@


\end{document}

